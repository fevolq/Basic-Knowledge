1.全部查询
  select*from 表名;
  select 字段1,・・・,字段n from 表名; ――将所有字段都写上

2.去重查询
  当某个字段内有数据重复时，使用distinct可去重
  select 字段 from 表名; ――查询指定字段内所有的数据，并全部返回
  select distinct 字段 from 表名; ――查询字段内所有数据，但重复的数据只返回一个

  select distinct 字段1,字段2 from 表名; ――当某条记录的字段1和字段2的数据都与另一条记录相同时，才会去重

  注：distinct一般必须写在字段前面，不然会报错，但有些特别的用法可以结合着写到字段的中间或者后面
      （distinct 想写在其他字段后面需要配合聚合函数来写）

3.四则运算查询
  通过查询语句查出来的表是内存中的一个虚拟表

  select 字段1,字段2*n from 表名; ――查询字段1和字段2，且字段2的数据都乘以n，字段2的字段名变成“字段2*n”
  select 字段1,字段2*n as 新字段 from 表名; ――查询结果同上，但给与了字段2一个新的字段名

4.自定义显示格式
  concat()函数用于连接字符串

  select concat("名字1：",字段1,"名字2：",字段2,・・・) as 新字段名 from 表名;
  返回的结果中只有一个字段（名字是“新字段”），里面的数据是cancat函数括号中的形式（字段1、2变成原表中对应的数据）
  eg.
mysql> select concat("姓名：",name,"   年薪：",salary*12) as annual_salary  from employee;
+------------------------------------+
| annual_salary                                |
+------------------------------------+
| 姓名：egon   年薪：87603.96        |
| 姓名：alex   年薪：12000003.72     |
| 姓名：wupeiqi   年薪：99600.00     |
| 姓名：yuanhao   年薪：42000.00     |
| 姓名：liwenzhou   年薪：25200.00   |
| 姓名：jingliyang   年薪：108000.00 |
| 姓名：jinxin   年薪：360000.00     |
| 姓名：成龙   年薪：120000.00       |
| 姓名：歪歪   年薪：36001.56        |
| 姓名：丫丫   年薪：24004.20        |
| 姓名：丁丁   年薪：12004.44        |
| 姓名：星星   年薪：36003.48        |
| 姓名：格格   年薪：48003.96        |
| 姓名：张野   年薪：120001.56       |
| 姓名：程咬金   年薪：240000.00     |
| 姓名：银   年薪：228000.00         |
| 姓名：铜   年薪：204000.00         |
| 姓名：铁   年薪：180000.00         |
+------------------------------------+
  select concat("名字1：",字段1,"名字2：",字段2,・・・) as 新字段名1,字段3 from 表名;
  select concat("名字1：",字段1,"名字2：",字段2,・・・) as 新字段名1,concat("名字3：",字段3) as 新字段名2 from 表名;
  这样可分成两列

  select concat_ws("拼接符",字段1,字段2,・・・) as 新字段名 from 表名; ――concat_ws()第一个参数为分隔符来进行拼接

5.case语句加工操作
  通过case语句来结合条件对查询结果进行一些加工
  select (case 
              when 字段1=“数据1” then 字段1
              when 字段1=“数据2” then concat(字段1,"拼接项1")
              else concat(字段1,"拼接项2") 
              end) as 新字段名,字段2 from 表名;
  当字段1的数据是“数据1”时直接返回，当字段1的数据是“数据2”时，将其与“拼接项1”进行拼接再返回，
  当字段1的数据不是“数据1”或“数据2”时，将其与“拼接项2”进行拼接再返回，字段2直接查询。

6.where约束
  where后跟条件语句
  select 字段1,字段2,・・・ from where 条件语句;
  eg. select id,name from 表名 where id=6; ――查询id=6的记录条中的id和name

  之前我们用where 后面跟的语句是id=1这种类型的，用=号连接的，除了=号外，还能使用其他的，看下面：
　　1. 比较运算符：> < >= <= <> !=
　　2. between 80 and 100 值在80到100之间（开区间，没有等于）
　　3. in(80,90,100)  值是80或90或100
　　4. like 'egon%' 模糊查询
    　　pattern可以是%或_，
    　　%表示任意多字符
    　　_表示一个字符 
　　5. 逻辑运算符：在多个条件直接可以使用逻辑运算符 and or not
　　6. is (not) null 判断是否为null（不能用=，只能用is）
            注意：''是空字符串，不是null，两个是不同的东西，null是啥也没有，''是空的字符串的意思，是一种数据类型，null是另外一种数据类型
  
7.分组查询
  group by
  1.将所有记录按照某个相同字段进行归类，比如针对员工信息表的职位分组，或者按照性别进行分组等
  2.为何要分组呢？是因为我们有时候会需要以组为单位来统计一些数据或者进行一些计算的
  
  select 字段1 from 表名 group by 字段1; ――只能查询到该字段，想要获取组内其他相关信息，要借助函数

  group by关键字和group_concat()函数一起使用的例子：
  select 字段1,group_concat(字段2) from 表名 group by 字段1; ――通过字段1分组，并查看组内的所有字段2数据，以逗号拼接
  select 字段1,group_concat(字段2,"：",字段3) from 表名 group by 字段1; ――查看字段2和字段3的数据，两个数据以冒号拼接， 不同记录间以逗号分隔。
  group by一般都会与聚合函数一起使用，聚合是什么意思：聚合就是将分组的数据聚集到一起，合并起来拿到一个最后的结果。
  
  关于聚合函数，mysql提供了以下几种聚合函数：count（总数量）、max、min、avg（平均值）、sum（总和）等，上面的group_concat也算是一个聚合函数。

8.排序查询
  order by
  按单列排序
        select*from 表名 order by 字段名; ――默认是升序排列
        select*from 表名 order by 字段名 asc; ――升序
        select*from 表名 order by 字段名 desc; ――降序
  按多列排序：先按照某一字段进行排序，在数据相同的一些记录中再进行一次排序
        select*from 表名 order by 字段1 desc,字段2 asc; ――先按字段1进行降序排列，然后将排序后的字段1对应的数据的相同部分按字段2进行升序排列。

9.限制查询
  limit限制查询出的记录数量

  select*from 表名 order by 字段1 desc limit 3; ――按字段1进行降序，从第一条开始取出3条数据，默认初始位置为0.
   
  select*from 表名 order by 字段1 desc limit 0,5; ――从第0开始，即先查询出第一条，然后包含这一条在内往后查5条。

  select*from 表名 order by 字段1 desc limit 5,5；――从第5开始，即先查询出第6条，然后包含这一条在内往后查5条。

  select * from 表名 order by 字段 desc limit 1; ――查询最后一条数据

  注：limit a,b;  即从第a条后面开始，查出b条数据。

10.正则查询
  使用like模糊查询只有%和_，比较局限。正则是通用的。
  select 字段1 from 表名 where 字段2 regexp "正则表达式"; ――查询字段2内符合正则的记录条内的字段1的数据
  eg.
        select*from 表名 where 字段名 regexp "^abc"; ――查询指定字段内的以abc开头的数据。
        select*from 表名 where 字段名 regexp "abc$"; ――查询指定字段内的以abc结尾的数据。


  

